---
layout: post
title:  "[leetcode] Daliy Temperature"
date:   2021-03-14 02:48:54 +0900
categories: jekyll update
---
### Daliy Temperatures

[Daily Temperatures - LeetCode](https://leetcode.com/problems/daily-temperatures/)

오늘은 Daily Temperature 라는 문제를 풀며 느낀점을 적어보겠습니다.

이 문제는 온도(숫자)의 배열이 주어지고, 그것을 연속하는 날짜의 기온이라고 했을 때,

해당 날짜의 몇 일 뒤에 따듯해지는지를 나타내는 또 다른 배열을 리턴하는 문제입니다.

😉 Ex) Input : [1,2,3] , Output : [1,1,0]

## 첫 번째 방법 (Brute force)

![Untitled (8)](https://user-images.githubusercontent.com/22024761/111038965-f06ee300-846e-11eb-8f58-9ba835e5fac0.png)

배열을 순차적으로 순회하며, 각 원소를 지날 때마다 그 뒤에 있는 원소들은 보면서

기준 온도보다 높은 온도가 있는지 검사하는 방식입니다.

시간 복잡도 : O(n^2)

공간 복잡도 : O(1)

매우 직관적이고 구현도 간단하지만 시간 복잡도가 썩 좋지 않군요...

하지만 당연히 이 점도 염두하고 있었고, 곧 바로 다음 방법을 실행했습니다.

## 두 번째 방법 (Map을 사용한 개선 시도)

![Untitled (9)](https://user-images.githubusercontent.com/22024761/111038966-f1a01000-846e-11eb-8cd1-7efdd976959b.png)

Two Sum 문제에서도 map을 사용했듯이 같은 생각을 했습니다.

"Search time을 줄여보자!"

따라서 key : 온도, value : 인덱스 배열 이 되는 맵을 먼저 구성해놓고,

그 다음 온도 배열을 순회하며 해당 온도보다 높은 온도가 map에 존재하는지를 검사하는 방법입니다.

시간 복잡도 : O(n log n)

공간 복잡도 : O(n)

문제의 추가적인 조건은 온도가 항상 30~100도 사이라는 점이고, constant라는 것을 활용해

시간 복잡도를 O(n log n)으로 만들 수 있었습니다.

하지만 뭔가 썩 만족스럽지 않더군요. Two Sum에서도 발생했던 문제인

1. 볼 필요 없는 값들이 계속 map에 남아 있음.

때문이었던 거 같습니다.

이번에는 아무리 생각해도 뾰족한 수가 생각나지 않더군요...

결국 Discussion에서 형님들의 생각을 학습하기로 했습니다.

## 세 번째 방법 (Stack을 사용한 방법)

저는 애초에 이 문제가 n에 해결될 거라 생각지도 못했는데, O (n)에 해결할 수 있는 방법이 있더군요..

그 방법을 소개하겠습니다.

![Untitled (10)](https://user-images.githubusercontent.com/22024761/111038969-f369d380-846e-11eb-96aa-76106d18ef44.png)

일단 index를 저장하는 stack을 구성합니다.

그리고 온도 배열을 **뒤에서부터** 순회하며 stack에 인덱스를 채워넣습니다.

혹시나 의문이 생기실만한 두 가지를 미리 정리해봅니다.

1. 뒤에서부터 순회하는 이유는 불필요한 항목을 검사하지 않기 위해서입니다.
2. Index만 있어도 온도를 알 수 있기 때문에 온도는 따로 저장하지 않고 index만 저장합니다.

제가 Map을 사용하며 겪었던 불필요한 값들이 들어있는 문제를

뒤에서부터 순회하는 것으로 간단하게 해결해버리셨습니다;;  😂

그리고 저 스택을 어떤식으로 활용하냐면

![Untitled (11)](https://user-images.githubusercontent.com/22024761/111038970-f5339700-846e-11eb-85e2-816018d9cf04.png)

순회하면서 stack에 있는 값을 꺼냅니다. 내가 만족하는 값이 나올 때까지.

즉 위 그림에서는 71보다 큰 값이 나올 때까지 pop을 하는 것이죠.

그러다가 stack이 비워지게 되면, 배열 뒤에 자신보다 큰 값이 없다는 뜻이므로 0을

만약 stack에 값이 있다면 가장 위에있는 index 값을 가져와서 현재 인덱스와의 거리를 계산합니다.

시간 복잡도 : O(n)

공간 복잡도 : O(n)

Brute force 방법보다 공간복잡도가 올라가기는 했지만,

시간복잡도를 O(n)이라는 엄청난 수치로 단축시킬 수 있었습니다.

위 문제를 풀면서 느낀점은 

특정 문제에서의 최적화 방법이 모든 문제에서 통하는 것은 아니기 때문에,

무작정 적용하면 안 된다는 사실과,

for문은 뒤에서부터 돌 수도 있다는 사실

위 두 가지 사실입니다. 

항상 염두하고 코딩해야겠습니다.
