---
layout: post
title:  "[leetcode] Subarray Sum Equals k"
date:   2021-03-17 02:48:54 +0900
categories: jekyll update
---

오늘은 leetcode의 미디엄 난이도 중 꽤나 고민하게 만들었던 문제를 하나 가져왔습니다.

- Subarray Sum Equals K

[Subarray Sum Equals K - LeetCode](https://leetcode.com/problems/subarray-sum-equals-k/)

숫자 배열, 그리고 임의의 숫자 k가 주어집니다.

숫자 배열의 Subarray 중 k와 값이 일치하는 갯수를 찾는 간단한 문제인데요.

Ex) array : [1,2,3] , k : 2   /  answer : 2 ( [1,2], [3] )

구현은 그리 간단하지 않았습니다;  🤔 

접근 방법을 하나하나 함께 생각해보시져

## 1. Brute force

주로 다중 for 문이나 재귀함수에 해당하는 brute force 솔루션은 필수 코스입니다.

그래야 생각의 흐름을 이야기하기도 쉽고, 정 생각이 안 날 때에는

이렇게라도 구현해서 working하는 코드를 만들어낼 수 있기 때문이죠.

먼저 이런 전략이 떠오릅니다.

1. 모든 부분 배열을 구한다
2. 구한 부분 배열의 합을 구한다
3. 부분 배열의 합과 k가 일치하면 count를 1 증가시킨다.

완벽합니다.

위 내용 그대로 구현해보죠

모든 부분 배열을 구하려면 이중 for 문을 사용해야합니다.

![Untitled](https://user-images.githubusercontent.com/22024761/111404909-eff67680-8712-11eb-855b-f8a201f2ce8e.png)

게다가 그 안에서 합을 구하려면 또 한 번 for 문을 돌아야하죠..

시간 복잡도 : O(n^3)

공간 복잡도 : O(1)

말이 안 되는 시간 복잡도가 나와버렸습니다 ㅋ

그래도 조금 생각하니 곧바로 개선점이 보이더군요.

## 2. 부분 배열을 구함과 동시에 sum 구하기

부분 배열을 만든 다음에 그 배열에 대한 sum을 하는 것이 아니라,

부분 배열을 만들면서 바로 sum을 계산하는 것이죠!

이게 무슨 말이냐면

![Untitled (1)](https://user-images.githubusercontent.com/22024761/111404911-f08f0d00-8712-11eb-950d-beec4a9b8ddc.png)

기존에는 부분 배열을 범위를 바탕으로 만들고, 다시 한 번 그 배열을 순회하면서 sum을 계산했습니다.

근데 어차피 우리가 원하는 것은 부분 배열이 아닌 sum 이거든요.

그래서 따로 부분배열을 만들지 않고 범위를 바탕으로 sum만 계산하겠다는 것입니다.

따라서

시간 복잡도 : O(n^2)

공간 복잡도 : O(1)

로 시간 복잡도를 개선할 수 있었습니다.

근데 이게 웬걸? JavaScript는 TLE(Time Limit Error)를 맞아버립니다. 😓

더 효율적인 알고리즘이 있다는 건데...

제 머리에선 나오지 않아서 결국 solution을 보고야 말았습니다.

## 3. HashMap with sum

이 방법은 솔루션을 한참을 봐도 이해하기가 힘들었습니다.

아마 제 글을 읽는 분들도 똑같을 거라 생각하기에 최대한 자세히 말씀 드리겠습니다.

기본 원리는 이렇습니다.

1. 현재까지의 sum을 구한다.
2. Map에 저장된 "과거의 sum" 중에 "현재의 sum"-k인 값을 모두 찾아 갯수를 더한다. 

(이유: 해당 인덱스부터 현재 인덱스까지의 부분합이 k이기 때문)

 3.  현재의 sum을 map에 추가한다.

 정리하자면, sum의 결과물들을 map으로 저장하고 현재 인덱스에서 부분합이 k인 지점을 찾을 때 활용한다 정도로 정리하면 되겠습니다.

![Untitled (2)](https://user-images.githubusercontent.com/22024761/111404913-f127a380-8712-11eb-8c8b-c4521f03dfa6.png)

 위 그림에서 가장 중요한 부분은 어디일까요?

 당연 가장 글씨가 큰 'Sum의 배열'이라고 생각해야한다는 겁니다.

 문제를 풀다보면 내가 지금 사용하는 값이 배열의 값인지, 배열의 sum을 사용하는 건지

 혼동이 오게됩니다.

 그러나 우리가 사용하는 것은 오로지 배열의 합! 합! 합! 입니다.

 결국 그림에서 설명했듯이 배열을 순회하며 합을 계산하고, - O(n)

 예전에 있었던 합 중에 sum-k가 되는 값이 있는지를 확인 - O(1) - HashMap이라서

 하면 해결되는 문제였던 것입니다. 

 시간 복잡도 : O(n)

 공간 복잡도 : O(n)

 이전 합을 map에 저장하기 위해 메모리를 조금 더 쓰기는 했지만

 그로 인해 n^3의 문제를 n 으로 획기적으로 줄일 수 있었습니다.

 부분합은 특정 시점의 합을 통해서도 구할 수 있다는 사실이 몸에 체득돼있지 않으면,

 솔루션을 봐도 이해하기 어려운 방법이라고 생각합니다!

 문제는 배열에 담긴 숫자가 아니라 오로지 sum을 보고 해결한다는 사실!

 이것만 기억하고 이해하려고 하면 훨씬 문제가 쉬워질 거 같습니다.
